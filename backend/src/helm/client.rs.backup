use std::process::Stdio;
use tokio::process::Command;
use tokio::io::AsyncWriteExt;
use anyhow::{Result, Context};
use tracing::{info, warn, error};

/// Cliente para interactuar con Helm CLI
#[derive(Clone)]
pub struct HelmClient {
    namespace: String,
}

impl HelmClient {
    pub fn new(namespace: String) -> Self {
        Self { namespace }
    }

    /// Get the configured namespace
    pub fn namespace(&self) -> &str {
        &self.namespace
    }

    /// Instalar un chart Helm
    pub async fn install_chart(
        &self,
        release_name: &str,
        chart: &str,
        version: Option<&str>,
        values: Option<&serde_json::Value>,
    ) -> Result<String> {
        // Para charts con problemas de imágenes bloqueadas, usar kubectl directamente
        if chart == "rabbitmq" {
            return self.install_rabbitmq_with_kubectl(release_name).await;
        }

        // Si el chart no contiene "/", asumir que es de bitnami
        let full_chart = if chart.contains('/') {
            chart.to_string()
        } else {
            format!("bitnami/{}", chart)
        };

        info!("Installing Helm chart: {} (release: {})", full_chart, release_name);

        let mut cmd = Command::new("helm");
        cmd.arg("install")
            .arg(release_name)
            .arg(&full_chart)
            .arg("--namespace")
            .arg(&self.namespace)
            .arg("--create-namespace");

        if let Some(ver) = version {
            cmd.arg("--version").arg(ver);
        }

        if let Some(vals) = values {
            // Crear archivo temporal con values
            let values_yaml = serde_yaml::to_string(vals)
                .context("Failed to serialize values to YAML")?;
            let temp_file = format!("/tmp/helm-values-{}.yaml", release_name);
            tokio::fs::write(&temp_file, &values_yaml).await
                .context("Failed to write values file")?;
            cmd.arg("--values").arg(&temp_file);
        }

        let output = cmd
            .stdout(Stdio::piped())
            .stderr(Stdio::piped())
            .output()
            .await
            .context("Failed to execute helm install")?;

        let stdout = String::from_utf8_lossy(&output.stdout);
        let stderr = String::from_utf8_lossy(&output.stderr);

        info!("Helm install stdout: {}", stdout);
        if !stderr.is_empty() {
            warn!("Helm install stderr: {}", stderr);
        }

        if output.status.success() {
            info!("Helm chart installed successfully");
            Ok(stdout.to_string())
        } else {
            error!("Helm install failed: {}", stderr);
            Err(anyhow::anyhow!("Helm install failed: {}", stderr).into())
        }
    }

    /// Instalar RabbitMQ usando kubectl directamente (para evitar problemas con imágenes bloqueadas)
    async fn install_rabbitmq_with_kubectl(&self, release_name: &str) -> Result<String> {
        info!("Installing RabbitMQ with kubectl: {}", release_name);

        // Crear un deployment simple de RabbitMQ
        let deployment_yaml = format!(r#"
apiVersion: apps/v1
kind: Deployment
metadata:
  name: {}
  namespace: {}
  labels:
    app: rabbitmq
    networksim-app: {}
spec:
  replicas: 1
  selector:
    matchLabels:
      app: rabbitmq
      networksim-app: {}
  template:
    metadata:
      labels:
        app: rabbitmq
        networksim-app: {}
    spec:
      containers:
      - name: rabbitmq
        image: rabbitmq:management-alpine
        ports:
        - containerPort: 5672
          name: amqp
        - containerPort: 15672
          name: management
        env:
        - name: RABBITMQ_DEFAULT_USER
          value: "user"
        - name: RABBITMQ_DEFAULT_PASS
          value: "password"
        resources:
          requests:
            memory: "256Mi"
            cpu: "250m"
          limits:
            memory: "512Mi"
            cpu: "500m"
---
apiVersion: v1
kind: Service
metadata:
  name: {}
  namespace: {}
  labels:
    app: rabbitmq
    networksim-app: {}
spec:
  selector:
    app: rabbitmq
    networksim-app: {}
  ports:
  - name: amqp
    port: 5672
    targetPort: 5672
  - name: management
    port: 15672
    targetPort: 15672
  type: ClusterIP
"#, release_name, self.namespace, release_name, release_name, release_name, release_name, self.namespace, release_name, release_name);

        // Aplicar el deployment
        let mut cmd = Command::new("kubectl");
        cmd.arg("apply")
            .arg("-f")
            .arg("-")
            .stdin(std::process::Stdio::piped())
            .stdout(std::process::Stdio::piped())
            .stderr(std::process::Stdio::piped());

        let mut child = cmd.spawn()
            .context("Failed to spawn kubectl")?;

        // Escribir el YAML al stdin
        if let Some(mut stdin) = child.stdin.take() {
            stdin.write_all(deployment_yaml.as_bytes()).await
                .context("Failed to write deployment YAML")?;
            stdin.flush().await?;
        }

        let output = child.wait_with_output().await
            .context("Failed to execute kubectl apply")?;

        let stdout = String::from_utf8_lossy(&output.stdout);
        let stderr = String::from_utf8_lossy(&output.stderr);

    /// Instalar RabbitMQ usando kubectl directamente (para evitar problemas con imágenes bloqueadas)
    async fn install_rabbitmq_with_kubectl(&self, release_name: &str) -> Result<String> {
        info!("Installing RabbitMQ with kubectl: {}", release_name);

        // Crear un deployment simple de RabbitMQ
        let deployment_yaml = format!(r#"
apiVersion: apps/v1
kind: Deployment
metadata:
  name: {}
  namespace: {}
  labels:
    app: rabbitmq
    networksim-app: {}
spec:
  replicas: 1
  selector:
    matchLabels:
      app: rabbitmq
      networksim-app: {}
  template:
    metadata:
      labels:
        app: rabbitmq
        networksim-app: {}
    spec:
      containers:
      - name: rabbitmq
        image: rabbitmq:management-alpine
        ports:
        - containerPort: 5672
          name: amqp
        - containerPort: 15672
          name: management
        env:
        - name: RABBITMQ_DEFAULT_USER
          value: "user"
        - name: RABBITMQ_DEFAULT_PASS
          value: "password"
        resources:
          requests:
            memory: "256Mi"
            cpu: "250m"
          limits:
            memory: "512Mi"
            cpu: "500m"
---
apiVersion: v1
kind: Service
metadata:
  name: {}
  namespace: {}
  labels:
    app: rabbitmq
    networksim-app: {}
spec:
  selector:
    app: rabbitmq
    networksim-app: {}
  ports:
  - name: amqp
    port: 5672
    targetPort: 5672
  - name: management
    port: 15672
    targetPort: 15672
  type: ClusterIP
"#, release_name, self.namespace, release_name, release_name, release_name, release_name, self.namespace, release_name, release_name);

        // Aplicar el deployment
        let mut cmd = Command::new("kubectl");
        cmd.arg("apply")
            .arg("-f")
            .arg("-")
            .stdin(std::process::Stdio::piped())
            .stdout(std::process::Stdio::piped())
            .stderr(std::process::Stdio::piped());

        let mut child = cmd.spawn()
            .context("Failed to spawn kubectl")?;

        // Escribir el YAML al stdin
        if let Some(mut stdin) = child.stdin.take() {
            stdin.write_all(deployment_yaml.as_bytes()).await
                .context("Failed to write deployment YAML")?;
            stdin.flush().await?;
        }

        let output = child.wait_with_output().await
            .context("Failed to execute kubectl apply")?;

        let stdout = String::from_utf8_lossy(&output.stdout);
        let stderr = String::from_utf8_lossy(&output.stderr);

        if output.status.success() {
            info!("RabbitMQ deployment created successfully: {}", stdout);
            Ok(format!("RabbitMQ deployed with kubectl: {}", release_name))
        } else {
            error!("Failed to create RabbitMQ deployment: {}", stderr);
            Err(anyhow::anyhow!("Failed to deploy RabbitMQ: {}", stderr).into())
        }
    }

    /// Desinstalar un release Helm
    pub async fn uninstall_release(&self, release_name: &str) -> Result<String> {
        info!("Uninstalling Helm release: {}", release_name);

        let output = Command::new("helm")
            .arg("uninstall")
            .arg(release_name)
            .arg("--namespace")
            .arg(&self.namespace)
            .stdout(Stdio::piped())
            .stderr(Stdio::piped())
            .output()
            .await
            .context("Failed to execute helm uninstall")?;

        let stdout = String::from_utf8_lossy(&output.stdout);
        let stderr = String::from_utf8_lossy(&output.stderr);

        if output.status.success() {
            info!("Helm release uninstalled successfully: {}", stdout);
            Ok(stdout.to_string())
        } else {
            warn!("Helm uninstall stderr: {}", stderr);
            // Para releases desplegados con kubectl, intentar eliminar con kubectl
            if stderr.contains("release") && stderr.contains("not found") {
                return self.uninstall_with_kubectl(release_name).await;
            }
            Err(anyhow::anyhow!("Helm uninstall failed: {}", stderr).into())
        }
    }

    /// Desinstalar usando kubectl (para releases desplegados directamente con kubectl)
    async fn uninstall_with_kubectl(&self, release_name: &str) -> Result<String> {
        info!("Uninstalling with kubectl: {}", release_name);

        // Eliminar deployment y service
        let output = Command::new("kubectl")
            .arg("delete")
            .arg("deployment,service")
            .arg(release_name)
            .arg("--namespace")
            .arg(&self.namespace)
            .arg("--ignore-not-found=true")
            .stdout(Stdio::piped())
            .stderr(Stdio::piped())
            .output()
            .await
            .context("Failed to execute kubectl delete")?;

        let stdout = String::from_utf8_lossy(&output.stdout);
        let stderr = String::from_utf8_lossy(&output.stderr);

        if output.status.success() {
            info!("Resources deleted with kubectl: {}", stdout);
            Ok(format!("Uninstalled with kubectl: {}", release_name))
        } else {
            error!("Failed to delete resources with kubectl: {}", stderr);
            Err(anyhow::anyhow!("Failed to uninstall: {}", stderr).into())
        }
    }

    /// Obtener logs de un release
    pub async fn get_logs(&self, release_name: &str, tail_lines: usize) -> Result<String> {
        info!("Getting logs for release: {}", release_name);

        // Primero intentar con helm
        let helm_output = Command::new("helm")
            .arg("status")
            .arg(release_name)
            .arg("--namespace")
            .arg(&self.namespace)
            .arg("--show-resources")
            .stdout(Stdio::piped())
            .stderr(Stdio::piped())
            .output()
            .await;

        if helm_output.is_ok() && helm_output.as_ref().unwrap().status.success() {
            // Es un release Helm, obtener logs usando kubectl
            return self.get_logs_with_kubectl(release_name, tail_lines).await;
        }

        // Si no es Helm, asumir que es kubectl y obtener logs directamente
        self.get_logs_with_kubectl(release_name, tail_lines).await
    }

    /// Obtener logs usando kubectl
    async fn get_logs_with_kubectl(&self, release_name: &str, tail_lines: usize) -> Result<String> {
        let output = Command::new("kubectl")
            .arg("logs")
            .arg(format!("deployment/{}", release_name))
            .arg("--namespace")
            .arg(&self.namespace)
            .arg(format!("--tail={}", tail_lines))
            .stdout(Stdio::piped())
            .stderr(Stdio::piped())
            .output()
            .await
            .context("Failed to execute kubectl logs")?;

        let stdout = String::from_utf8_lossy(&output.stdout);
        let stderr = String::from_utf8_lossy(&output.stderr);

        if output.status.success() {
            Ok(stdout.to_string())
        } else {
            // Si falla, intentar con pods directamente
            warn!("Failed to get logs from deployment, trying pods: {}", stderr);
            self.get_logs_from_pods(release_name, tail_lines).await
        }
    }

    /// Obtener logs de pods directamente
    async fn get_logs_from_pods(&self, release_name: &str, tail_lines: usize) -> Result<String> {
        // Obtener nombre del pod
        let pod_output = Command::new("kubectl")
            .arg("get")
            .arg("pods")
            .arg("--namespace")
            .arg(&self.namespace)
            .arg("-l")
            .arg(format!("networksim-app={}", release_name))
            .arg("-o")
            .arg("jsonpath={.items[0].metadata.name}")
            .stdout(Stdio::piped())
            .stderr(Stdio::piped())
            .output()
            .await
            .context("Failed to get pod name")?;

        if !pod_output.status.success() {
            return Err(anyhow::anyhow!("No pods found for release: {}", release_name).into());
        }

        let pod_name = String::from_utf8_lossy(&pod_output.stdout).trim();

        if pod_name.is_empty() {
            return Err(anyhow::anyhow!("No pods found for release: {}", release_name).into());
        }

        let output = Command::new("kubectl")
            .arg("logs")
            .arg(pod_name)
            .arg("--namespace")
            .arg(&self.namespace)
            .arg(format!("--tail={}", tail_lines))
            .stdout(Stdio::piped())
            .stderr(Stdio::piped())
            .output()
            .await
            .context("Failed to get logs from pod")?;

        let stdout = String::from_utf8_lossy(&output.stdout);
        let stderr = String::from_utf8_lossy(&output.stderr);

        if output.status.success() {
            Ok(stdout.to_string())
        } else {
            Err(anyhow::anyhow!("Failed to get logs: {}", stderr).into())
        }
    }
